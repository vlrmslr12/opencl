1. LARGE_INTEGER 공용체           LARGE_INTEGER 공용체는 부호가 있는 64비트 정수형 데이터를 저장하기 위해 선언된 사용자 정의    데이터 형입니다. 64비트 정수를 사용할수 있도록 정의한 이유는 microsecond(1/1000000초)까지     측정하여 좀 더 정확한 시간값을 저장하기 위함입니다.     만약 컴파일러가 64비트를 지원할 때에는 공용체에 선언된 QuadPart 라는 64비트 정수형 변수에     측정값을 저장하고, 32비트만 지원되는 경우에는 LowPart, HightPart 라는 32비트 정수형 변수에     64비트 측정값을 나누어 저장합니다.      LARGE_INTEGER 사용자 정의 데이터형은 공용체(union) 키워드로 선언되어 있기 때문에 값이     공용체 내부에 선언된 어느 변수에 저장되더라도 같이 선언된 변수들과 공유하게 됩니다.    LARGE_INTEGER 공용체는 아래와 같이 선언되어 있습니다.     typedef union _LARGE_INTEGER {         struct {            DWORD LowPart;       // 32비트 정수형 데이터            LONG  HighPart;        // 32비트 정수형 데이터        };        LONGLONG QuadPart;    // 64비트 정수형 데이터    } LARGE_INTEGER;      선언된 형식을 보면 구조체(LowPart와 HightPart) 와 QuadPart 변수가 대등하게 선언되었기 때문에    두 변수값들이 값을 서로 공유하게 됩니다. 즉, LowPart와 HightPart 에 값이 대입되면 QuadPart    변수를 통해서도 저장된 값을 확인할 수 있습니다.     구조체 선언시 내부 변수 이름이 HighPart, LowPart 순이 아니라 LowPart, HighPart 순으로 정의된    이유는 윈도우즈 시스템의 바이트 오더가 리틀 인디언 형식( Little-endian format ) 을 사용하기     때문입니다. 그래서 64비트 정수형인 QuadPart 값이 32비트 단위로 역순으로 배열되어 있기 때문에    이 값들을 올바르게 얻기 위해서 LowPart, HighPart 순으로 정의한 것입니다.     바이트 오더에 대하여 자세한 설명은 아래의 링크를 참고하시기 바랍니다.    * 리틀 인디안에 대해서... - http://www.tipssoft.com/bulletin/tb.php/old_bbs/8      2. QueryPerformanceCounter 와 QueryPerformanceFrequency 함수     컴퓨터의 메인보드에는 하나의 고해상도 타이머가 존재합니다. 이 타이머는 정확하고 일정한 주파수    (즉, 1초에 각 타이머의 성능에 맞는 진동수)를 갖기 때문에 측정하고자 하는 코드들의 시작과 끝에서    CPU 클럭수를 얻어 그 차로 수행시간을 얻을 수 있습니다.     고해상도 타이머를 사용하기 위해서는 QueryPerformanceCounter 함수와 QueryPerformanceFrequency    함수를 사용합니다. 각 함수에 대한 설명은 아래와 같습니다.      2.1 QueryPerformanceCounter 함수         고해상도 타이머의 현재 CPU의 클럭수를 얻는 함수입니다. 함수의 원형은 아래와 같습니다.         BOOL QueryPerformanceCounter( LARGE_INTEGER *lpPerformanceCount );         이 함수의 매개 변수에는 LARGE_INTEGER 의 포인터를 명시합니다. lpPerformanceCount 에는        함수가 호출된 시점의 고해상도 타이머 값이 설정됩니다.          이 함수는 타이머가 지원되는 경우 0 이 아닌 수를 반환하고, 타이머가 지원되지 않는 경우에는         0 을 반환합니다.      2.2 QueryPerformanceFrequency         고해상도 타이머의 주파수(1초당 진동수)를 반환합니다. 함수의 원형은 아래와 같습니다.         BOOL QueryPerformanceFrequency( LARGE_INTEGER *lpFrequency );         이 함수의 매개 변수에는 LARGE_INTEGER 의 포인터를 명시합니다. lpFrequency 에는 해당         타이머의 주파수가 설정됩니다. 만약 타이머가 지원되지 않는 경우에는 lpFrequency 에 0 이        설정될 수도 있습니다.         이 함수는 타이머가 지원되는 경우 0 이 아닌 수를 반환하고, 타이머가 지원되지 않는 경우에는         0 을 반환합니다.        3. 진동수를 시간 단위로 변환하기     수행 시간은 측정하고자 하는 명령의 시작 부분에서 얻은 값과 끝 부분에서 얻은 값의 차를 이용하여     구할 수 있습니다. QueryPerformanceCounter 함수에서 얻은 고해상도 타이머의 값을 이용하여 수행    시간을 구하는데 이 값은 절대적인 타이머에 의한 값이 아니라 시스템마다 다른 타이머를 가지기 때문에    두 시점간의 차이 값을 구한 경우 QueryPerformanceFrequency 함수를 호출하여 얻은 주파수로 나누어    원하는 시간 단위로 변경하는 작업을 추가적으로 수행해야 합니다.          위와 같이 시작 시점과 끝 시점에서 QueryPerformanceCounter 함수를 호출하면 각 시점에서 타이머가    반환한 CPU 클럭수를 얻을 수 있습니다. 여기에서 B 클럭수에서 A 클럭수를 뺀 값이 수행시간 동안 발생한    C 클럭수가 될 것입니다. 그러나 이 값은 시간 단위가 아니기 때문에 QueryPerformanceFrequency    함수로 얻은 주파수로 나누어 시간 단위로 변환해야 합니다.      이때 주파수의 값을 변경하여 C 클럭수를 나누면 얻어지는 수행시간의 단위가 달라집니다. 기본적으로     주파수가 1초동안 발생하는 진동수인데 이 주기를 1000으로 나누게 되면 1/1000초(밀리초) 동안 발생하는     진동수가 됩니다. 그래서  C 클럭수를 주파수로 나누면 초 단위의 수행시간이 얻어지고, "주파수/1000" 으로     나누면 밀리초 단위의 수행시간이 얻어집니다. 마이크로초 단위의 수행시간을 얻기 위해서는 주파수를    10000000 을 나눈 값을 이용하면 됩니다. 이렇게 주파수의 시간 단위를 변경하여 C 클럭수를 나누면 원하는     시간 단위의 수행시간 값을 얻을 수 있습니다.     4. 간단한 예제 #include <windows.h>#include <winbase.h>void main(){    // 시작, 끝, 주파수를 얻을 구조체를 선언한다.    LARGE_INTEGER start, end, f;     // 고해상도 타이머의 주파수를 얻는다.    QueryPerformanceFrequency(&f);     // 시작 시점의 CPU 클럭수를 얻는다.    QueryPerformanceCounter(&start);     // 프로세스를 0.001초간 중지시킨다.    Sleep(1);     // 끝 시점의 클럭수를 얻는다.    QueryPerformanceCounter(&end);     // 끝 시점의 CPU 클럭수에서 시작 시점의 클럭수를 뺀 후 주파수를 1000으로 나눈 값을 나눈다.    // 1초 기준의 주파수를 1000 으로 나누었기 때문에 1밀리초 동안 발생하는 진동수로 나눈 셈이다.    __int64 ms_interval = (end.QuadPart - start.QuadPart)/(f.QuadPart/1000);     // 끝 시점의 CPU 클럭수에서 시작 시점의 클럭수를 뺀 후 주파수에서 1000000으로 나눈 값을 나눈다.    // 1초 기준의 주파수를 1000000 으로 나누었기 때문에 1마이크로초 동안 발생하는 진동수로 나눈 셈이다.    __int64 micro_interval = (end.QuadPart - start.QuadPart)/(f.QuadPart/1000000);     // 결과 값을 밀리초와 마이크로초로 출력한다.    printf("millisecond : %d, microsecond : %d\n", (int)ms_interval, (int)micro_interval);}
